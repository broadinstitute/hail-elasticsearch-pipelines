#!/usr/bin/env python

import os
import argparse

p=argparse.ArgumentParser()
p.add_argument("-c", "--solr-collection", help="Solr collection")
p.add_argument("-i", "--dataset-id", help="Dataset id", required=True)
p.add_argument("-b", "--block-size", help="Block size", default=10)
p.add_argument("vds_path", help="Path of the VEP-annotated vds to load")
args=p.parse_args()

dataset_id=args.dataset_id
block_size=args.block_size

print("========================================================================")
print("  EXPORT_TO_SOLR_WITH_REF_STORED %(dataset_id)s " % locals())
print("========================================================================")

vds_path=os.path.abspath(args.vds_path)

def run(cmd):
    print(cmd)
    os.system(cmd)


hail_command="hail_local_with_3_cores" # if args.local else "hail_with_3_cores"
if args.solr_collection:
    solr_collection=args.solr_collection
else:
    solr_collection=dataset_id + "_with_ref_stored"

print("Running %s on %s" % (hail_command, solr_collection))

run(
"""
date;
time %(hail_command)s \
  read -i file://%(vds_path)s \
  annotatevariants vds -r va.clinvar -i file:///mnt/lustre/weisburd/data/reference_data/clinvar/clinvar_v2016_09_01.vds \
  annotatevariants vds -r va.exac -i file:///mnt/lustre/weisburd/data/reference_data/exac/exac_v1.vds \
  annotatevariants vds -r va.g1k -i file:///mnt/lustre/weisburd/data/reference_data/1kg/1kg_wgs_phase3.vds \
  annotatevariants vds -r va.dbnsfp -i file:///mnt/lustre/weisburd/data/reference_data/dbnsfp/dbNSFP_3.2a_variant.filtered.allhg19_nodup.vds \
  annotatevariants expr -c 'va.vep.sorted_transcript_consequences=va.vep.transcript_consequences.map(c => select(c, amino_acids, biotype, canonical, cdna_start, cdna_end, codons, consequence_terms, distance, domains, exon, gene_id, transcript_id, protein_id, gene_symbol, gene_symbol_source, hgnc_id, hgvsc, hgvsp, lof, lof_flags, lof_filter, lof_info)).sortBy(c => 
        let is_coding=(c.biotype=="protein_coding") and is_most_severe=c.consequence_terms.toSet.contains(va.vep.most_severe_consequence) and is_canonical=(c.canonical==1) in
            if(is_coding) 
                if(is_most_severe) 
                    if(is_canonical)  1  else  2
                else  3
            else
                if(is_most_severe) 
                    if(is_canonical)  4  else  5
                else  6
        )' \
  exportvariantssolr --block-size %(block_size)s --num-shards 3 --export-ref --export-missing -c %(solr_collection)s -v '
    dataset_id { stored=true, docValues=false } = "%(dataset_id)s",
    chrom { stored=true, docValues=false } = v.contig,
    start { stored=true, docValues=false } = v.start,
    end { stored=true, docValues=false } = v.start + v.ref.length - 1,
    ref { stored=true, docValues=false } = v.ref,
    alt { stored=true, docValues=false } = v.alt,
    filters { stored=true, docValues=false } = va.filters,
    pass { stored=true, docValues=false } = va.pass,
    rsid { stored=true, docValues=false } = va.rsid,
    AC { stored=true, docValues=false } = va.info.AC[va.aIndex-1],
    AN { stored=true, docValues=false } = va.info.AN,
    AF { stored=true, docValues=false } = va.info.AF[va.aIndex-1],
    was_split { stored=true, docValues=false } = va.wasSplit,
    clinvar_clinsig { stored=true, docValues=false } = va.clinvar.clinical_significance,
    clinvar_review_status { stored=true, docValues=false } = va.clinvar.review_status,
    clinvar_inheritance_mode { stored=true, docValues=false } = va.clinvar.inheritance_modes.split(";").toSet,
    clinvar_disease_mechanism { stored=true, docValues=false } = va.clinvar.disease_mechanism.split(";").toSet,
    clinvar_gold_stars { stored=true, docValues=false } = va.clinvar.gold_stars,
    clinvar_is_pathogenic { stored=true, docValues=false } = va.clinvar.pathogenic,
    clinvar_is_conflicted { stored=true, docValues=false } = va.clinvar.conflicted,

    vep_gene_id { stored=true } = va.vep.transcript_consequences.map( x => x.gene_id ).toSet,
    vep_transcript_id { stored=true, docValues=false } = va.vep.transcript_consequences.map( x => x.transcript_id ).toSet,
    vep_most_severe_consequence { stored=true, docValues=false } = va.vep.most_severe_consequence,

    g1k_wgs_phase3_afr_af { stored=true, docValues=false } = va.g1k.info.AFR_AF[va.g1k.aIndex-1],
    g1k_wgs_phase3_amr_af { stored=true, docValues=false } = va.g1k.info.AMR_AF[va.g1k.aIndex-1],
    g1k_wgs_phase3_eur_af { stored=true, docValues=false } = va.g1k.info.EUR_AF[va.g1k.aIndex-1],
    g1k_wgs_phase3_eas_af { stored=true, docValues=false } = va.g1k.info.EAS_AF[va.g1k.aIndex-1],
    g1k_wgs_phase3_sas_af { stored=true, docValues=false } = va.g1k.info.SAS_AF[va.g1k.aIndex-1],
    g1k_wgs_phase3_global_af { stored=true, docValues=false } = va.g1k.info.AF[va.g1k.aIndex-1],
    g1k_wgs_phase3_popmax_af { stored=true, docValues=false } = va.g1k.info.POPMAX_AF,
    g1k_wgs_phase3_popmax { stored=true, docValues=false } = va.g1k.info.POPMAX,
    exac_v1_afr_af { stored=true, docValues=false } = if(va.exac.info.AN_AFR == 0) NA:Double else va.exac.info.AC_AFR[va.exac.aIndex-1]/va.exac.info.AN_AFR,
    exac_v1_amr_af { stored=true, docValues=false } = if(va.exac.info.AN_AMR == 0) NA:Double else va.exac.info.AC_AMR[va.exac.aIndex-1]/va.exac.info.AN_AMR,
    exac_v1_nfe_af { stored=true, docValues=false } = if(va.exac.info.AN_NFE == 0) NA:Double else va.exac.info.AC_NFE[va.exac.aIndex-1]/va.exac.info.AN_NFE,
    exac_v1_fin_af { stored=true, docValues=false } = if(va.exac.info.AN_FIN == 0) NA:Double else va.exac.info.AC_FIN[va.exac.aIndex-1]/va.exac.info.AN_FIN,
    exac_v1_eas_af { stored=true, docValues=false } = if(va.exac.info.AN_EAS == 0) NA:Double else va.exac.info.AC_EAS[va.exac.aIndex-1]/va.exac.info.AN_EAS,
    exac_v1_sas_af { stored=true, docValues=false } = if(va.exac.info.AN_SAS == 0) NA:Double else va.exac.info.AC_SAS[va.exac.aIndex-1]/va.exac.info.AN_SAS,
    exac_v1_global_af { stored=true, docValues=false } = va.exac.info.AF[va.exac.aIndex-1],
    exac_v1_popmax_af { stored=true, docValues=false } = if(va.exac.info.AN_POPMAX[va.exac.aIndex-1] == 0) NA:Double else va.exac.info.AC_POPMAX[va.exac.aIndex-1]/va.exac.info.AN_POPMAX[va.exac.aIndex-1],
    exac_v1_popmax { stored=true, docValues=false } = va.exac.info.POPMAX[va.exac.aIndex-1],
    twinsuk_af { stored=true, docValues=false } = va.dbnsfp.TWINSUK_AF.toDouble,
    alspac_af { stored=true, docValues=false } = va.dbnsfp.ALSPAC_AF.toDouble,
    esp65000_aa_af { stored=true, docValues=false } = va.dbnsfp.ESP6500_AA_AF.toDouble,
    esp65000_ea_af { stored=true, docValues=false } = va.dbnsfp.ESP6500_EA_AF.toDouble,

    dbnsfp_sift_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.SIFT_pred, 
    dbnsfp_polyphen2_hdiv_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.Polyphen2_HDIV_pred,
    dbnsfp_polyphen2_hvar_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.Polyphen2_HVAR_pred,
    dbnsfp_lrt_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.LRT_pred,
    dbnsfp_muttaster_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.MutationTaster_pred.split(";").toSet,    
    dbnsfp_mutassesor_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.MutationAssessor_pred.split(";").toSet, 
    dbnsfp_fathmm_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.FATHMM_pred.split(";").toSet,
    dbnsfp_provean_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.PROVEAN_pred.split(";").toSet,
    dbnsfp_metasvm_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.MetaSVM_pred.split(";").toSet,
    dbnsfp_metalr_pred { stored=true, docValues=false, indexed=false } = va.dbnsfp.MetaLR_pred.split(";").toSet,
    dbnsfp_cadd_phred { stored=true, docValues=false, indexed=false } = va.dbnsfp.CADD_phred.toFloat,
    vep_annotations_sorted { stored=true, docValues=false, type="text_ws", indexed=false } = json(va.vep.sorted_transcript_consequences),
    vep_consequences=va.vep.transcript_consequences.map( x => x.consequence_terms ).flatten().toSet,
    clinvar_submitter { stored=true, docValues=false, indexed=false } = va.clinvar.all_submitters.split(";").toSet,
    clinvar_trait { stored=true, docValues=false, indexed=false } = va.clinvar.all_traits.split(";").toSet,
    clinvar_pmid { stored=true, docValues=false, indexed=false } = va.clinvar.all_pmids.split(";").toSet,
    clinvar_age_of_onset { stored=true, docValues=false, indexed=false } = va.clinvar.age_of_onset.split(";").toSet,    
    clinvar_prevalence { stored=true, docValues=false, indexed=false } = va.clinvar.prevalence.split(";").toSet,
    clinvar_origin { stored=true, docValues=false, indexed=false } = va.clinvar.origin.split(";").toSet,
    clinvar_xrefs { stored=true, docValues=false, indexed=false } = va.clinvar.xrefs
    ' \
  -g 'num_alt { stored=true, docValues=false } = if(g.isCalled) g.nNonRefAlleles else -1,
    gq { stored=true, docValues=false } = if(g.isCalled) g.gq else NA:Int,
    ab { stored=true, docValues=false } = let s=g.ad.sum in if(g.isCalled && s != 0) (g.ad[0] / s).toFloat else NA:Float, 
    dp { stored=true, docValues=false } = if(g.isCalled) g.dp else NA:Int,
    pl { stored=true, docValues=false, indexed=false } = if(g.isCalled) g.pl else NA:Array[Int]' \
  -z '69.173.112.35:2181,69.173.112.36:2181,69.173.112.37:2181' ;
date;
""" % locals())



#  annotatevariants table -r va.omim --impute file:///mnt/lustre/weisburd/data/reference_data/omim/omim.tsv  \

"""



"""

